scilla_version 1


library ZDExchange

let fee_ratio_kept = Uint128 997
let fee_ratio_denom = Uint128 1000
let one = Uint128 1
let zero = Uint128 0
let none_uint = None {Uint128}

(* returns Uint128 *)
let input_price =
    fun (input_amount : Uint128) =>
    fun (input_reserve : Uint128) =>
    fun (output_reserve : Uint128) =>
        (* assert input_reserve > 0 and output_reserve > 0 *)
        let input_fee_kept = builtin mul input_amount fee_ratio_kept in
        let numerator = builtin mul input_fee_kept output_reserve in
        let input_reserve_denom = builtin mul input_reserve fee_ratio_denom in
        let denominator = builtin add input_reserve_denom input_fee_kept in
        builtin div numerator denominator

(* returns Uint128 *)
let output_price =
    fun (output_amount : Uint128) =>
    fun (input_reserve : Uint128) =>
    fun (output_reserve : Uint128) =>
        (* assert input_reserve > 0 and output_reserve > 0 *)
        let in_res_out_amount = builtin mul input_reserve output_amount in
        let numerator = builtin mul in_res_out_amount fee_ratio_denom in
        let out_res_amount = builtin sub output_reserve output_amount in
        let denominator = builtin mul out_res_amount fee_ratio_kept in
        let ratio = builtin div numerator denominator in
        builtin add ratio one

(* Modified from SimpleDex *)
(* returns singleton List Message *)
let one_msg =
    fun (msg : Message) =>
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg

(* Modified from FungibleToken *)
let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end

contract ZDExchange
()

field tokenCount : Uint128 = Uint128 0
field id_to_token : Map Uint128 ByStr20 = Emp Uint128 ByStr20
field token_names : Map ByStr20 String = Emp ByStr20 String
field token_symbols : Map ByStr20 String = Emp ByStr20 String
field token_decimals : Map ByStr20 Uint32 = Emp ByStr20 Uint32
field token_totalSupplies : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field token_balances : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field token_allowances : Map ByStr20 (Map ByStr20 (Map ByStr20 Uint128)) = Emp ByStr20 (Map ByStr20 (Map ByStr20 Uint128))

transition CreateMarket (token : ByStr20)
    (* Modifies fields tokenCount, id_to_token, token_names, token_symbols, *)
    (* token_decimals, token_totalSupplies, token_balances, token_allowances *)
end

transition AddLiquidity (token : ByStr20, min_liquidity : Uint128,
        max_tokens : Uint128, deadline : BNum)
    (* payable *)
    (* Modifies fields token_totalSupplies, token_balances *)
    (* returns Uint128 *)
end

transition RemoveLiquidity (token : ByStr20, min_zil : Uint128,
        deadline : BNum, recipient : ByStr20)
    (* Modifies fields token_totalSupplies, token_balances *)
    (* returns Uint128 *)
    (* sends funds *)
end

transition ZilToTokenSwapInput (token : ByStr20, min_tokens : Uint128,
        deadline : BNum)
    (* payable *)
    (* calls FungibleToken.Transfer() *)
    (* returns Uint128 *)
end

transition ZilToTokenTransferInput (token : ByStr20, min_tokens : Uint128,
        deadline : BNum, recipient : ByStr20)
    (* payable *)
    (* calls FungibleToken.Transfer() *)
    (* returns Uint128 *)
end

transition ZilToTokenSwapOutput (token : ByStr20, tokens_bought : Uint128,
        deadline : BNum)
    (* payable *)
    (* calls FungibleToken.Transfer() *)
    (* returns Uint128 *)
end

transition ZilToTokenTransferOutput(token : ByStr20, tokens_bought : Uint128,
        deadline : BNum, recipient : ByStr20)
    (* payable *)
    (* calls FungibleToken.Transfer() *)
    (* returns Uint128 *)
end

transition TokenToZilSwapInput (token : ByStr20, tokens_sold : Uint128,
        min_zil : Uint128, deadline : BNum)
    (* calls FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
    (* sends funds *)
end

transition TokenToZilTransferInput (token : ByStr20, tokens_sold : Uint128,
        min_zil : Uint128, deadline : BNum, recipient : ByStr20)
    (* calls FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
    (* sends funds *)
end

transition TokenToZilSwapOutput (token : ByStr20, zil_bought : Uint128,
        max_tokens : Uint128, deadline : BNum)
    (* calls FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
end

transition TokenToZilTransferOutput (token : ByStr20, zil_bought : Uint128,
        max_tokens : Uint128, deadline : BNum, recipient : ByStr20)
    (* calls FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
end

transition TokenToTokenSwapInput (token : ByStr20, tokens_sold : Uint128,
        min_tokens_bought : Uint128, min_zil_bought : Uint128,
        deadline : BNum, token_other : ByStr20)
    (* calls FungibleToken.Transfer(), FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
end

transition TokenToTokenTransferInput(token : ByStr20, tokens_sold : Uint128,
        min_tokens_bought : Uint128, min_zil_bought : Uint128,
        deadline : BNum, token_other : ByStr20, recipient : ByStr20)
    (* calls FungibleToken.Transfer(), FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
end

transition TokenToTokenSwapOutput (token : ByStr20, tokens_bought : Uint128,
        max_tokens_sold : Uint128, max_zil_sold : Uint128,
        deadline : BNum, token_other : ByStr20)
    (* calls FungibleToken.Transfer(), FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
end

transition TokenToTokenTransferOutput (token : ByStr20, tokens_bought : Uint128,
        max_tokens_sold : Uint128, max_zil_sold : Uint128,
        deadline : BNum, token_other : ByStr20, recipient : ByStr20)
    (* calls FungibleToken.Transfer(), FungibleToken.TransferFrom() *)
    (* returns Uint128 *)
end

(** FungibleToken-like Transitions **)

(* Transfer deposited token balance of _sender *)
transition Transfer (token : ByStr20, to: ByStr20, tokens : Uint128)
    (* Modifies field token_balances *)
    (* returns Bool in transferred *)
    balances <- token_balances[token];
    match balances with
    |   Some bs =>
        (* Modified from FungibleToken *)
        bal <- token_balances[token][_sender];
        match bal with
        | Some b =>
          can_do = le_int tokens b;
          match can_do with
          | True =>
            (* subtract tokens from _sender and add it to "to" *)
            new_sender_bal = builtin sub b tokens;
            token_balances[token][_sender] := new_sender_bal;

            (* Adds tokens to "to" address *)
            to_bal <- token_balances[token][to];
            new_to_bal = match to_bal with
            | Some x => builtin add x tokens
            | None => tokens
            end;
        	  token_balances[token][to] := new_to_bal;
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; to : to; tokens : tokens;
                    transferred : True };
            msgs = one_msg msg;
            send msgs
          | False =>
            (* balance not sufficient. *)
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; to : to; tokens : tokens;
                    transferred : False;
                    message : "Balance not Sufficient" };
            msgs = one_msg msg;
            send msgs
          end
        | None =>
            (* no balance record, can't transfer *)
        	msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; to : to; tokens : tokens;
                    transferred : False;
                    message : "Balance not Found" };
            msgs = one_msg msg;
            send msgs
        end
    |   None =>
        msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                token : token; to : to; tokens : tokens;
                transferred : False;
                message : "Token not Found" };
        msgs = one_msg msg;
        send msgs
    end
end

transition TransferFrom (token : ByStr20, from : ByStr20, to: ByStr20,
        tokens : Uint128)
    (* Modifies field token_balances *)
    (* returns Bool in transferred *)
    balances <- token_balances[token];
    match balances with
    |   Some bs =>
        (* Modified from FungibleToken *)
        bal <- token_balances[token][from];
        match bal with
        | Some b =>
          can_do = le_int tokens b;
          match can_do with
          | True =>
            (* subtract tokens from from and add it to "to" *)
            allowance <- token_allowances[token][from][to];
            match allowance with
            |   Some a =>
                allowance_sufficient = le_int tokens a;
                match allowance_sufficient with
                |   True =>
                    new_from_bal = builtin sub b tokens;
                    token_balances[token][from] := new_from_bal;

                    (* Adds tokens to "to" address *)
                    to_bal <- token_balances[token][to];
                    new_to_bal = match to_bal with
                    | Some x => builtin add x tokens
                    | None => tokens
                    end;
                	  token_balances[token][to] := new_to_bal;
                    msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                            token : token; from : from; to : to; tokens : tokens;
                            transferredFrom : True };
                    msgs = one_msg msg;
                    send msgs
                |   False =>
                    msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                            token : token; from : from; to : to; tokens : tokens;
                            transferredFrom : False;
                            message : "Allowance not Sufficient" };
                    msgs = one_msg msg;
                    send msgs
                end
            |   None =>
                msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                        token : token; from : from; to : to; tokens : tokens;
                        transferredFrom : False;
                        message : "Allowance not Found" };
                msgs = one_msg msg;
                send msgs
            end
          | False =>
            (* balance not sufficient. *)
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; from : from; to : to; tokens : tokens;
                    transferredFrom : False;
                    message : "Balance not Sufficient" };
            msgs = one_msg msg;
            send msgs
          end
        | None =>
            (* no balance record, can't transfer *)
        	msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; from : from; to : to; tokens : tokens;
                    transferredFrom : False;
                    message : "Balance not Found" };
            msgs = one_msg msg;
            send msgs
        end
    |   None =>
        msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                token : token; from : from; to : to; tokens : tokens;
                transferredFrom : False;
                message : "Token not Found" };
        msgs = one_msg msg;
        send msgs
    end
end

transition Approve (token : ByStr20, spender : ByStr20, tokens : Uint128)
    (* Modifies field token_allowances *)
    (* returns Bool in approved *)
    allowances <- token_allowances[token];
    match allowances with
    |   Some as =>
        token_allowances[token][_sender][spender] := tokens;
        msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                token : token; spender : spender; tokens : tokens;
                approved : True };
        msgs = one_msg msg;
        send msgs
    |   None =>
        msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                token : token; spender : spender; tokens : tokens;
                approved : False;
                message : "Token not Found" };
        msgs = one_msg msg;
        send msgs
    end
end

(* Price function for Zil -> Token trades *)
transition ZilToTokenInputPrice (token : ByStr20, zil_sold : Uint128)
    (* returns Uint128 *)
end

(* Price function for Zil -> Token trades *)
transition ZilToTokenOutputPrice (token : ByStr20, tokens_sold : Uint128)
    (* returns Uint128 *)
end

(* Price function for Token -> Zil trades *)
transition TokenToZilInputPrice (token : ByStr20, tokens_sold : Uint128)
    (* returns Uint128 *)
end

(* Price function for Token -> Zil trades *)
transition TokenToZilOutputPrice (token : ByStr20, zil_bought : Uint128)
    (* returns Uint128 *)
end

(* Gets token address from token_id *)
transition TokenAddress (token_id : Uint128)
    (* returns Option ByStr20 in token_address *)
    token_address <- id_to_token[token_id];
    msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
            token_id : Uint128;
            token_address : token_address };
    msgs = one_msg msg;
    send msgs
end

(** FungibleToken-like Constant Transitions **)

(* Checks deposited token balance of tokenOwner *)
transition BalanceOf (token : ByStr20, tokenOwner : ByStr20)
    (* returns Uint128 in balance *)
    (* message gives extra info *)
    balances <- token_balances[token];
    match balances with
    |   Some bs =>
        balance <- token_balances[token][tokenOwner];
        match balance with
        |   Some b =>
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; tokenOwner : tokenOwner;
                    balance : b };
            msgs = one_msg msg;
            send msgs
        |   None =>
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; tokenOwner : tokenOwner;
                    balance : zero };
            msgs = one_msg msg;
            send msgs
        end
    |   None =>
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; tokenOwner : tokenOwner;
                    balance : zero;
                    message : "Token not Found" };
            msgs = one_msg msg;
            send msgs
    end
end

(* Checks allowance of spender with tokenOwner *)
transition Allowance (token : ByStr20, tokenOwner : ByStr20, spender : ByStr20)
    (* returns Option Uint128 in allowance *)
    (* message gives extra info *)
    allowances <- token_allowances[token];
    match allowances with
    |   Some as =>
        allowance <- token_allowances[token][tokenOwner][spender];
        match allowance with
        |   Some a =>
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; tokenOwner : tokenOwner; spender : spender;
                    allowance : a};
            msgs = one_msg msg;
            send msgs
        |   None =>
            msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                    token : token; tokenOwner : tokenOwner; spender : spender;
                    allowance : zero};
            msgs = one_msg msg;
            send msgs
        end
    |   None =>
        msg = { _tag : "Main"; _recipient : _sender; _amount : zero;
                token : token; tokenOwner : tokenOwner; spender : spender;
                allowance : zero;
                message : "Token not Found" };
        msgs = one_msg msg;
        send msgs
    end
end
